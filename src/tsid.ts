import { decode, encode, uniformInt } from './utils'

const TSID_BYTES_LENGTH = 8
const TSID_CHARS_LENGTH = 13
const TSID_HEX_CHARS_LENGTH = 16

const _EPOCH_ISO = '2020-01-01T00:00:00+00:00'
const TSID_EPOCH = new Date(_EPOCH_ISO).getTime()

const RANDOM_BITS = 22
const RANDOM_MASK = 0x3fffff

const TSID_DEFAULT_NODE_BITS = 10

/** Base 32 */
const ALPHABET = '0123456789ABCDEFGHJKMNPQRSTVWXYZ'
const ALPHABET_VALUES: Array<number> = Array.from({ length: 128 }, () => -1)

function _setAlphabetValues(chars: string, start: number): void {
  for (let i = 0; i < chars.length; i++) {
    ALPHABET_VALUES[chars.charCodeAt(i)] = start + i
    ALPHABET_VALUES[chars.charCodeAt(i).toString().toUpperCase().charCodeAt(0)] = start + i
  }
}

_setAlphabetValues('0123456789', 0)
_setAlphabetValues('abcdefghjkmnpqrstvwxyz', 0xa)
_setAlphabetValues('oi', 0)
_setAlphabetValues('l', 1)

type StringFormat = 's' | 'S' | 'x' | 'X' | 'd' | 'z'

export const getTsid: () => TSID = () => TSID.create()

export class TSID {
  /**
   * A value object that represents a Time-Sorted Unique Identifier (TSID).

       TSID is a 64-bit value that has 2 components:

       - Time component (42 bits): a number of milliseconds since 2020-01-01
         (Unix epoch).
       - Random component (22 bits): a sequence of random bits generated by a
         secure random generator.

       The Random component has 2 sub-parts:
       - Node (0 to 20 bits): a number used to identify the machine or node.
       - Counter (2 to 22 bits): a randomly generated number that is
         incremented whenever the time component is repeated.

       The random component layout depend on the node bits. If the node bits
       are 10, the counter bits are limited to 12. In this example, the
       maximum node value is `2^10-1 = 1023` and the maximum counter value is
       `2^12-1 = 4093`. So the maximum TSIDs that can be generated per
       millisecond per node is `4096`.

       Instances of this class are immutable.

       See [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID).
   */
  private readonly _number: bigint
  private _epoch: number

  constructor(number: bigint) {
    this._number = number & BigInt('0xFFFFFFFFFFFFFFFF') // 64-bit
    this._epoch = TSID_EPOCH
  }

  setEpoch(epoch: number) {
    this._epoch = epoch
  }

  /**
   * Returns the timestamp component of the TSID.
   *
   * The timestamp is the number of milliseconds elapsed since the TSID epoch.
   *
   * @returns {number} The timestamp value.
   *
   * @example
   * // The timestamp of a TSID with value 0 should be equal to TSID_EPOCH.
   * TSID(0).timestamp === TSID_EPOCH; // true
   *
   * // The timestamp of a newly created TSID should be close to the current time.
   * TSID.create().timestamp - time.time() * 1000 < 1; // true
   *
   * // The timestamp of a TSID with value (1 << RANDOM_BITS) should be TSID_EPOCH + 1.
   * TSID(1 << RANDOM_BITS).timestamp === TSID_EPOCH + 1; // true
   */
  get timestamp(): number {
    return this._epoch + Number(this._number >> BigInt(RANDOM_BITS))
  }

  /**
   * Returns the random component of the TSID.
   *
   * This component contains the node and counter bits.
   *
   * @returns {number} The random component value.
   *
   * @example
   * // The random component of a TSID with value 0 should be 0.
   * TSID(0).random === 0; // true
   *
   * // The random component of a TSID with value 1 should be 1.
   * TSID(1).random === 1; // true
   *
   * // The random component of a TSID with a specific value should be the expected value.
   * TSID((0xffffffff << RANDOM_BITS) + 255).random === 255; // true
   */
  get random(): number {
    return Number(this._number & BigInt(RANDOM_MASK))
  }

  /**
   * Converts the TSID into a bigint object.
   *
   * This simply unwraps the internal value.
   *
   * @returns {bigint} The bigint object representation of the TSID.
   *
   * @example
   * // The number representation of a TSID with a specific value should be the expected value.
   * TSID(0xffff0000000000000000).number === 0; // true
   *
   * // The number representation of a TSID with value 0 should be 0.
   * TSID(0x0000000000000000).number === 0; // true
   *
   * // The number representation of a TSID with value 0xffff should be 0xffff.
   * TSID(0xffff).number === 0xffff; // true
   */
  get number(): bigint {
    return this._number
  }

  toBigInt = () => this._number

  private toCanonicalString(): string {
    return Array.from(
      { length: 13 },
      (_, i) => ALPHABET[Number((this._number >> BigInt(60 - i * 5)) & BigInt(0x1f))]
    ).join('')
  }

  /**
   * Converts the TSID into a byte array.
   *
   * @returns {Uint8Array} The byte array representation of the TSID.
   *
   * @example
   * // Convert a TSID with value 1 into a byte array and check if it matches the expected result.
   * const t1 = TSID(1);
   * t1.toBytes() === new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); // true
   *
   * // Convert a TSID with value 0xfabada into a byte array and check if it matches the expected result.
   * const t2 = TSID(0xfabada);
   * t2.toBytes() === new Uint8Array([0, 0, 0, 0, 0, 0xfa, 0xba, 0xda]); // true
   *
   * // Convert a TSID with a larger value into a byte array and check if it matches the expected result.
   * const t3 = TSID(0xffcafefabadabeef);
   * t3.toBytes() === new Uint8Array([0xff, 0xca, 0xfe, 0xfa, 0xba, 0xda, 0xbe, 0xef]); // true
   *
   * // Convert a TSID with an even larger value into a byte array and check if it matches the expected result.
   * const t4 = TSID(0xffffffcafefabadabeef);
   * t4.toBytes() === new Uint8Array([0xff, 0xca, 0xfe, 0xfa, 0xba, 0xda, 0xbe, 0xef]); // true
   */
  toBytes(): Uint8Array {
    const byteArray = new Uint8Array(TSID_BYTES_LENGTH)
    for (let i = 0; i < TSID_BYTES_LENGTH; i++) {
      byteArray[i] = Number((this._number >> BigInt((TSID_BYTES_LENGTH - 1 - i) * 8)) & BigInt(0xff))
    }
    return byteArray
  }

  /**
   * Converts the TSID to a canonical string.
   *
   * @returns {string} The canonical string (13-chars length string) representation of the TSID.
   *
   * @example
   * // Convert a TSID to a canonical string.
   * const tsid = TSID.create()
   * const canonicalString = tsid.toString()
   * console.log(canonicalString) // Output: '0DXBG0DVMS8ER'
   */
  toString = (): string => this.toCanonicalString()

  toHexString = () => encode(this._number, 16, TSID_BYTES_LENGTH * 2)

  toDecimalString = () => encode(this._number, 10)

  toBase62String = () => encode(this._number, 62)

  /**
   * Converts the TSID into a string.
   *
   * Supports the following formats:
   * - `S`: canonical string in upper case.
   * - `s`: canonical string in lower case.
   * - `X`: hexadecimal in upper case.
   * - `x`: hexadecimal in lower case.
   * - `d`: base-10.
   * - `z`: base-62.
   *
   * @param {StringFormat} format - The desired format for the string representation.
   * @returns {string} The string representation of the TSID in the specified format.
   *
   * @example
   * // Create a TSID from a string and convert it to a canonical upper case string.
   * const t1 = TSID.fromString('0AWE5HZP3SKTK');
   * t1.toStringWithFormat('S') === '0AWE5HZP3SKTK'; // true
   *
   * // Convert the same TSID to a lower case canonical string.
   * t1.toStringWithFormat('s') === '0awe5hzp3sktk'; // true
   *
   * // Create a TSID from a string and convert it to hexadecimal in upper case.
   * const t2 = TSID.fromString('0AXFXR5W7VBX0');
   * t2.toStringWithFormat('X') === '0575FDC1787DAFA0'; // true
   *
   * // Create a TSID from a string and convert it to base-10.
   * const t3 = TSID(437283649808777971);
   * t3.toStringWithFormat('d') === '437283649808777971'; // true
   *
   * // Convert the same TSID to base-62.
   * t3.toStringWithFormat('z') === 'WIlLsHwljH'; // true
   */
  toStringWithFormat(format: StringFormat = 'S'): string {
    let result: string

    switch (format) {
      case 'S':
        result = this.toCanonicalString()
        break
      case 's':
        result = this.toCanonicalString().toLowerCase()
        break
      case 'X':
        result = encode(this._number, 16, TSID_BYTES_LENGTH * 2)
        break
      case 'x':
        result = encode(this._number, 16, TSID_BYTES_LENGTH * 2).toLowerCase()
        break
      case 'd':
        result = encode(this._number, 10)
        break
      case 'z':
        result = encode(this._number, 62)
        break
    }

    return result
  }

  /**
   * Returns a new TSID.
   *
   * This static method is a quick alternative to `TSIDGenerator::create()`.
   * It can generate up to `2^22` (`4,194,304`) TSIDs per millisecond.
   * It can be useful, for example, for logging.
   *
   * Security-sensitive applications that require a cryptographically secure pseudo-random generator should use `TSIDGenerator::create()`.
   *
   * > Note: This method is not thread-safe by default. It's the responsibility of TSIDGenerator to ensure thread safety.
   *
   * @returns {TSID} A new TSID instance.
   *
   * @example
   * // Create three TSIDs and ensure that they are in ascending order.
   * const a = TSID.create();
   * const b = TSID.create();
   * const c = TSID.create();
   * a.number < b.number < c.number; // true
   */
  static create(): TSID {
    return defaultGenerator.create()
  }

  /**
   * Converts a byte array into a TSID.
   *
   * @param {Uint8Array} bytes - The byte array to convert into a TSID.
   * @returns {TSID} The TSID created from the given byte array.
   *
   * @throws {Error} Thrown if the length of the byte array is not equal to `TSID_BYTES_LENGTH`.
   *
   * @example
   * // Convert a byte array with value 0 into a TSID and check if it equals TSID(0).
   * TSID.fromBytes(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0])) === TSID(0); // true
   *
   * // Convert a byte array with value 1 into a TSID and check if it equals TSID(1).
   * TSID.fromBytes(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1])) === TSID(1); // true
   *
   * // Convert a byte array with value 2 into a TSID and check if it equals TSID(2).
   * TSID.fromBytes(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2])) === TSID(2); // true
   *
   * // Convert a byte array with value 11 into a TSID and check if it equals TSID(11).
   * TSID.fromBytes(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 11])) === TSID(11); // true
   */
  static fromBytes(bytes: Uint8Array): TSID {
    if (bytes.length !== TSID_BYTES_LENGTH) {
      throw new Error(`Invalid TSID bytes (len=${bytes.length} bytes, expected ${TSID_BYTES_LENGTH})`)
    }

    const number = BigInt(
      '0x' +
        Array.from(bytes)
          .map((b) => b.toString(16).padStart(2, '0'))
          .join('')
    )
    return new TSID(number)
  }

  /**
   * Converts a string into a TSID.
   *
   * Supports the following formats:
   * - `S`: canonical string in upper case.
   * - `s`: canonical string in lower case.
   * - `X`: hexadecimal in upper case.
   * - `x`: hexadecimal in lower case.
   * - `d`: base-10.
   * - `z`: base-62.
   *
   * @param {string} value - The string to convert into a TSID.
   * @param {StringFormat} format - The format of the input string.
   * @returns {TSID} The TSID created from the given string.
   *
   * @throws {Error} Thrown if the length of the string is not equal to the expected length for the specified format.
   * @throws {Error} Thrown if the format is invalid.
   *
   * @example
   * // Convert a string in hexadecimal format to a TSID and check if its number matches another TSID.
   * const t1 = TSID.fromString('0575FDC1787DAFA0', 'X');
   * const t2 = TSID.fromString('0AXFXR5W7VBX0');
   * t1.number === t2.number; // true
   *
   * // Convert a string in base-10 format to a TSID.
   * const t3 = TSID.fromString('12345', 'd');
   * t3.number === BigInt(12345); // true
   *
   * // Convert a string in base-62 format to a TSID.
   * const t4 = TSID.fromString('abc123', 'z');
   * t4.number === BigInt(decode('abc123', 62)); // true
   */
  static fromString(value: string, format: StringFormat = 'S'): TSID {
    let number: bigint

    switch (format) {
      case 'S':
      case 's':
        if (value.length !== TSID_CHARS_LENGTH) {
          throw new Error(`Invalid TSID string: (len=${value.length} chars, but expected ${TSID_CHARS_LENGTH})`)
        }
        number = Array.from(value).reduce(
          (acc, c, i) => acc + (BigInt(ALPHABET_VALUES[c.charCodeAt(0)]) << BigInt(60 - i * 5)),
          BigInt(0)
        )
        break
      case 'X':
      case 'x':
        if (value.length !== TSID_HEX_CHARS_LENGTH) {
          throw new Error(`Invalid TSID string: (len=${value.length} chars, but expected ${TSID_HEX_CHARS_LENGTH})`)
        }
        number = BigInt(decode(value.toUpperCase(), 16))
        break
      case 'd':
        number = BigInt(decode(value, 10))
        break
      case 'z':
        number = BigInt(decode(value, 62))
        break
      default:
        throw new Error(`Invalid format: '${format}'`)
    }

    return new TSID(number)
  }
}

/**
 * Creates a new TSID generator.
 *
 * @param {number | null} node - Node identifier. Defaults to a random integer within the range of `node_bits`.
 * @param {number} nodeBits - Number of bytes used to represent the node id. Defaults to `TSID_DEFAULT_NODE_BITS`.
 * @param {number} epoch - Epoch start in milliseconds. Defaults to `TSID_EPOCH`.
 * @param {(n: number) => bigint} randomFunction - Function to use to randomize the counter. Must return an n-bit integer. If `null`, the stdlib `random.getrandbits()` is used.
 *
 * @throws {Error} Thrown if `node` is less than 0.
 * @throws {Error} Thrown if `nodeBits` is not in the range [0, 20].
 * @throws {Error} Thrown if `node` is too large for the given `nodeBits`.
 *
 * @example
 * // Create a TSID generator with a specific node and node bits.
 * const generator = new TSIDGenerator(1, 1);
 * generator.node; // 1
 */
export class TSIDGenerator {
  private readonly randomFunction: (n: number) => bigint
  private readonly node: number
  private readonly _epoch: number
  private readonly _nodeBits: number
  private readonly _counterBits: number
  private counter: bigint
  private _milliseconds: number
  private readonly _counterMask: bigint
  private readonly _nodeMask: bigint

  /**
   * Constructs a TSIDGenerator instance.
   *
   * @param {number | null} node - Node identifier. Defaults to a random integer within the range of `node_bits`.
   * @param {number} nodeBits - Number of bytes used to represent the node id. Defaults to `TSID_DEFAULT_NODE_BITS`.
   * @param {number} epoch - Epoch start in milliseconds. Defaults to `TSID_EPOCH`.
   * @param {(n: number) => bigint} randomFunction - Function to use to randomize the counter. Must return an n-bit integer. If `null`, the stdlib `random.getrandbits()` is used.
   */
  constructor(
    node: number | null = null,
    nodeBits: number = TSID_DEFAULT_NODE_BITS,
    epoch: number = TSID_EPOCH,
    randomFunction?: (n: number) => bigint
  ) {
    if (node !== null && node < 0) {
      throw new Error(`Invalid node: ${node}`)
    }

    if (nodeBits < 0 || nodeBits > 20) {
      throw new Error(`Invalid node_bits: ${nodeBits}`)
    }

    this.randomFunction = randomFunction || ((n: number) => BigInt(uniformInt(0, 2 ** n)))
    this.node = node === null ? Number(BigInt(uniformInt(0, 2 ** 20)) >> BigInt(20 - nodeBits)) : node

    if (this.node >> nodeBits > 0) {
      throw new Error(`Node ${this.node} too large for node_bits==${nodeBits}`)
    }

    this._epoch = epoch
    this._nodeBits = nodeBits
    this._counterBits = RANDOM_BITS - nodeBits
    this.counter = this.randomFunction(this._counterBits)

    this._milliseconds = new Date().getTime()
    this._counterMask = BigInt(RANDOM_MASK) >> BigInt(nodeBits)
    this._nodeMask = BigInt(RANDOM_MASK) >> BigInt(this._counterBits)
  }

  /**
   * Generates a new TSID.
   *
   * @returns {TSID} A new TSID instance.
   *
   * @example
   * // Generate a new TSID using the generator.
   * const t = generator.create();
   */
  create(): TSID {
    const currentMilliseconds = new Date().getTime()

    if (currentMilliseconds - this._milliseconds < 1) {
      this.counter += BigInt(1)

      if (this.counter >> BigInt(this._counterBits) !== BigInt(0)) {
        this._milliseconds += 1
        this.counter = BigInt(0)
      }
    } else {
      this._milliseconds = currentMilliseconds
      const rnd: bigint = this.randomFunction(this._counterBits)
      this.counter = rnd & this._counterMask
    }

    const milliseconds: bigint = BigInt(this._milliseconds - this._epoch) << BigInt(RANDOM_BITS)
    const node: bigint = (BigInt(this.node) & this._nodeMask) << BigInt(this._counterBits)
    const counter: bigint = this.counter & this._counterMask

    const result: TSID = new TSID(milliseconds + node + counter)
    result.setEpoch(this._epoch)
    return result
  }
}

const defaultGenerator: TSIDGenerator = new TSIDGenerator()
